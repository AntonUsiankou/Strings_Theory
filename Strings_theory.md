## **Strings Theory**


Вопрос 1.
Что появится в консоли в результате работы фрагмента программы?
String a = "java";
a.toUpperCase();
System.out.println(a);

**Ответ:** 
Будет выводится “java” в нижнем регистре, так как в метод toUpperCase() мы ничего не отправляем. Если чуть изменить код, то будет “JAVA” в верхнем регистре.
String a = "java";
System.out.println(toUpperCase(a));

Вопрос 2.
Что появится в консоли в результате работы фрагмента программы?
String s1 = "Java";
String s2 = "Java";
String s3 = new String("Java");
System.out.println("s1 == s2 : " + (s1 == s2));
System.out.println("s1 == s3 : " + (s1 == s3));
System.out.println(s1.equals(s3));
Поясните ответ.

**Ответ:**
s1 == s2 : true
s1 == s3 : false
true
Оператор == сравнивает адреса в памяти.
У класса String есть переопределенный метод equals(). И сравнивает он не ссылки, а именно последовательность символов в строках. И если текст в строках одинаковый, неважно, как они были созданы и где хранятся: в пуле строк, или в отдельной области памяти. Результатом сравнения будет true.
Источник. [https://javarush.ru/groups/posts/equals-java-sravnenie-strok]

Вопрос 3.
Можно ли выполнить наследование от класса String?
Почему?
**Ответ:** 
Класс, помеченный как final, не поддается наследованию и все его методы косвенным образом приобретают свойство final. Так как класс String является final следовательно он не может наследоваться.

**Источник.** [https://javarush.ru/groups/posts/1403-metodih-i-klassih-final-java]
[https://docs.oracle.com/javase/6/docs/api/java/lang/String.html]

Вопрос 4.
Назовите основные, на ваш взгляд, методы класса String.

**Ответ:**
Для сравнения строк можно воспользоваться методом equals().
Для перевода экземпляра любого Java-класса или любого примитивного типа данных к строковому представлению, можно использовать метод String.valueOf().
Double.parseDouble()/Integer.parseInt() для перевода строки в целочисленное значение в зависимости от самого значения.
Метод split() использовался для разделения строки на массив строк.
Indexof() для определения позиции в строке символа/подстроки в строке
Для извлечения подстроки из строки класс String в Java предоставляет методы substring();
int length() — определение длины строки;
boolean isEmpty() — возвращает true, если длина строки равна 0;
String trim() — удаление всех пробелов в начале и конце строки;
static String format(String format, Object… args), format(Locale l, String format, Object… args) — генерирует форматированную строку, полученную с использованием формата, интернационализации и др.;

Вопрос 5.
Какие разновидности конструкторов использует класс String?

**Ответ:** Класс String поддерживает несколько конструкторов, например:
•	String(),
•	String(String str),
•	String(byte[] asciichar),
•	String(char[] unicodechar),
•	String(StringBuffer sbuf),
•	String(StringBuilder sbuild) и др.
Эти конструкторы используются для создания объектов класса String на основе инициализации значениями из массива типа char, byte и др.
Когда Java встречает литерал, заключенный в двойные кавычки, автоматически создается объект-литерал типа String, на который можно установить ссылку. Таким образом, объект класса String можно создать, присвоив ссылке на класс значение существующего литерала или с помощью оператора new и конструктора.

**Источник.** [И. Блинов. Глава 7. Строки.]

Вопрос 6.
Какие классы в стандартной библиотеке Java работают со строками?

**Ответ:** Классы StringBuilder и StringBuffer являются «близнецами» и по своему предназначению близки к классу String, но в отличие от последнего содержимое и размеры объектов классов StringBuilder и StringBuffer можно изменять.

**Источник.** [И. Блинов. Глава 7. Строки.]


Вопрос 7.
Почему экземпляры класса String в Java неизменные и финализированные?

**Ответ:**
Есть несколько преимуществ в неизменности строк:
1.	Строковый пул возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много места в памяти (heap space), поскольку разные строковые переменные указывают на одну переменную в пуле. Если бы строка не была неизмененяемой, тогда бы интернирование строк не было бы возможным, потому что если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.
2.	Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае любой хакер может изменить значение ссылки и вызвать проблемы в безопасности приложения.
3.	Так как строка неизменная, она безопасна для много поточности и один экземпляр строки может быть совместно использован различными нитями. Это позволяет избежать синхронизации для потокобезопасности, строки полностью потокобезопасны.
4.	Строки используются в Java classloader и неизменность обеспечивает правильность загрузки класса при помощи Classloader. К примеру, задумайтесь об экземпляре класса, когда вы пытаетесь загрузить java.sql.Connection класс, но значение ссылки изменено на myhacked.Connection класс, который может осуществить нежелательные вещи с вашей базой данных.
5.	Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Это причина, почему строка наиболее часто используемый объект, используемый в качестве ключа HashMap.

**Источник.** [https://javarush.ru/groups/posts/760-java-string-voprosih-k-sobesedovaniju-i-otvetih-na-nikh-ch2]

Вопрос 8.
Заполните ячейки таблицы (Да/Нет).
Characteristic 				String		StringBuilder		StringBuffer
Неизменяемый (Immutable)?
Имеет пул (Pooled)?
Потокобезопасный (Thread-safe)?
Может изменять размер?

**Ответ:**
|:-----------------------------:|:-----:|:------------------:|:------------------:|
|Characteristic	                |String |	    StringBuilder|	     StringBuffer |
|:-----------------------------:|:-----:|:------------------:|:------------------:|
|Неизменяемый (Immutable)	    |    Нет|                  Да|	                Да|
|:-----------------------------:|:-----:|:------------------:|:------------------:|
|Имеет пул (Pooled)	            |     Да|	               Да|	                Да|
|:-----------------------------:|:-----:|:------------------:|:------------------:|
|Потокобезопасный (Thread-safe)	|     Да|                 Нет|	                Да|
|:-----------------------------:|:-----:|:------------------:|:------------------:|
|Может изменять размер	        |    Нет|	              Нет|	               Нет|
|:-----------------------------:|:-----:|:------------------:|:------------------:|

**Источник:** [https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java]
[https://docs.oracle.com/javase/8/docs/api/java/lang/String.htm]
[https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html]
[https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html]

Вопрос 9.
В чем разница и что общего между StringBuffer и StringBuilder?

**Ответ:**
Основным отличием StringBuilder от StringBuffer является потокобезопасность последнего. Более высокая скорость обработки есть следствие отсутствия потокобезопасности класса StringBuilder. Его следует применять, если не существует вероятности использования объекта в конкурирующих потоках.

**Источник.** [И. Блинов. Глава 7. Строки.]


Вопрос 10.
Когда лучше использовать StringBuffer, а когда StringBuilder?

**Ответ:**
Как уже сказано, StringBuffer — изменяемый класс, поэтому при работе с ним не возникает такого же количества мусора в памяти, как со String. Поэтому если над строками проводится много модификаций, лучше использовать StringBuffer.
Недостатки: Синхронизированные методы работают медленнее не сихнронизированных.

**Источник.** [https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java]

Вопрос 11.
Какие методы имеются в классах StringBuffer и StringBuilder, которые отсутствуют в классе String?

**Ответ:**
Следует обратить внимание на следующие методы:
•	void setLength(int n) — установка размера буфера;
•	void ensureCapacity(int minimum) — установка гарантированного минимального размера буфера;
•	int capacity() — возвращение текущего размера буфера;
•	StringBuffer append(параметры) — добавление к содержимому объекта
•	строкового представления аргумента, который может быть символом, значением базового типа, массивом и строкой;
•	StringBuffer insert(параметры) — вставка символа, объекта или строки в указанную позицию;
•	StringBuffer deleteCharAt(int index) — удаление символа;
•	StringBuffer delete(int start, int end) — удаление подстроки;
•	StringBuffer reverse() — обращение содержимого объекта

**Источник.** [И. Блинов. Глава 7. Строки.]

Вопрос 12.
Какие методы сравнения строк имеются в строковых классах?

**Ответ:**
boolean equals(Object ob) и equalsIgnoreCase(String s) — сравнение строк с учетом и без учета регистра соответственно;
int compareTo(String s) и compareToIgnoreCase(String s) — лексикографическое сравнение строк с учетом и без учета их регистра. Метод осуществляет вычитание кодов первых различных символов вызывающей и передаваемой строки в метод строк и возвращает целое значение. Метод возвращает значение нуль в случае, когда equals() возвращает значение true;
boolean contentEquals(StringBuffer ob) — сравнение строки и содержимого объекта типа StringBuffer;

**Источник.** [И. Блинов. Глава 7. Строки.]

Вопрос 13.
Используя функции строковых классов, написать фрагмент программы, которая будет определять, является ли строка палиндромом.

**Ответ:**
public static void main(String[] args){
    String s="wqqw";
    isPalindrome(s);
}
public static String reverseString(String s){
    String r = "";
    for (int i = s.length() - 1; i >= 0; --i)
    r += s.charAt(i);
    return r;
}
public static Boolean isPalindrome(String s) {
    if(s.equals(reverseString(s))){
        System.out.println("Полиндром");
    }else{
        System.out.println("Не полиндром");
    }
        return s.equals(reverseString(s));
}

Вопрос 14.
Что появится в консоли в результате работы фрагмента программы?
final String ZA = " за ";
String value = "ОТЧЕТ о перевозках пассажиров за январь 2019 г.";
String[] monthYear = value.split(ZA)[1].split(" ",3);
System.out.println(Arrays.toString(monthYear));
Поясните ответ.

**Ответ:**
[январь, 2019, г.]
В массиве строк обращаемся к 1 элементу, и вызываем метод split, разграничивая на " ", устанавливая порог (количество строк) равным 3, которые должны быть возвращены в массив строк monthYear.
У этого метода split() есть дополнительный параметр limit: он определяет, какое количество раз шаблон regex будет применяться к исходной строке.

**Источник.** [И. Блинов. Глава 7. Строки.]
[https://javarush.ru/groups/posts/2907-metod-split-v-java-delim-stroku-na-chasti]

Вопрос 15.
Что появится в консоли в результате работы фрагмента программы?
String s4 = "1" + 2 + 3;
String s5 = 1 + 2 + "3";
System.out.println(s4);
System.out.println(s5);
Поясните ответ.

**Ответ:**
Вывод будет таким:
123
33
Если мы выполняем + операцию в строке, то работает как append (конкатенация).
Поэтому в вашем первом случае 1+2+"3"… 1+2 =3 но когда он выполняет 3+"3" java concate 3 в String 3 равен 33.
Во втором примере "1"+2+3… 2 добавляется в строку “1”, которая получается как 12 а затем "12" + 3 поэтому результат равен 123.

Вопрос 16.
Что появится в консоли в результате работы фрагмента программы?
String s = "abcde ";
System.out.println(s.trim().length());
System.out.println(s.charAt(4));
System.out.println(s.indexOf('e'));
System.out.println(s.indexOf("de"));
System.out.println(s.substring(2, 4).toUpperCase());
System.out.println(s.replace('a', '1'));
System.out.println(s.contains("DE"));
System.out.println(s.startsWith("a"));
Поясните ответ.

**Ответ:**
Вывод будет таким:
5 – удаляет пробелы и считает количесво элементов в строке;
e – возвращает элемент на 4 позиции начиная с нуля;
4 – возвращает позицию по идентификатору;
3 – проверяет позицию по первому символу затем проверяет есть ли второй и возвращает позицию как у одного элемента массива;
CD - извлечение из строки подстроки, начиная с введенной позиции в верхнем регистре;
1bcde – меняет а на 1, но без присвоения;
False – не содержит подстроку DE в строке s;
True – строка начинается с подстроки.

Вопрос 17.
Что появится в консоли в результате работы фрагмента программы?
StringBuilder b = new StringBuilder();
b.append(12345).append('-');
System.out.println(b.length());
System.out.println(b.indexOf("-"));
System.out.println(b.charAt(2));
StringBuilder b2 = b.reverse();
System.out.println(b.toString());
System.out.println(b == b2);
Поясните ответ.

**Ответ:**
append(параметры) — добавление к содержимому объекта строкового представления аргумента, который может быть символом, значением базового типа, массивом и строкой;
6 – вывод числа элементов
5 – индекс первого вхождения подстроки в строку
3 – возврат символа строки по индексу
-54321 – возврат элементов в обратном порядке
True – проверка равенства двух значений


Вопрос 18.
Что появится в консоли в результате работы фрагмента программы?
StringBuilder s = new StringBuilder("abcde");
s.insert(1, '-').delete(3, 4);
System.out.println(s);
System.out.println(s.substring(2, 4));
Поясните ответ.

**Ответ:**
Выводится:
a-bde
bd
Мы вставляем в на первый элемент в строке – и удаляем элементы 3 до 4. Далее мы извлекаем элементы из строки в подстроку начиная с 2 до 4.

Вопрос 19.
StringBuffer sb = new StringBuffer("abcde");
sb.insert(2,"123");
sb.append("456");
sb.reverse();
Поясните ответ.

**Ответ:**
Выводится 654edc321ba
Первым действием создаем строковый объект sb. Далее добавляем подстроку в позицию 2. След. дейсвием добавляем в конец строкового объекта новую подстроку и реверсируем объект.

Вопрос 20.
Каким образом можно сцепить строки Java?
Назовите не менее 3 способов.

**Ответ:**
1.	"значение1" + "значение2"
2.	Помощью метода StringBuffer append(параметры)
3.	StringBuffer insert(параметры) — вставка символа, объекта или строки в указанную позицию;

Вопрос 21.
Чем отличаются пустая и нулевая строки?

**Ответ:**
Пустая строка отличается от нулевой ссылки тем, 
что в объектно-ориентированном языке программирования пустая ссылка на строковый тип не указывает
на строковый объект и вызовет ошибку при попытке выполнить с ним какую-либо операцию.


Вопрос 22.
В какой кодировке хранятся символы в строке?

**Ответ:** 
Строки в java хранятся в Unicode.

**Источник.** [https://javarush.ru/groups/posts/1544-urovenjh-22-otvetih-na-voprosih-k-sobesedovaniju-po-teme-urovnja]

Вопрос 23.
Какие интерфейсы реализуют классы String, StringBuffer и StringBuilder?

**Ответ:**
class String String implements java.io.Serializable, Comparable<String>, CharSequence, Constable, ConstantDesc;
class StringBuffer implements java.io.Serializable, Comparable<StringBuffer>, CharSequence;
class StringBuilder implements java.io.Serializable, Comparable<StringBuilder>, CharSequence;

Вопрос 24.
Что такое кодовые точки и кодовые единицы?

**Ответ:**
В языке Java строки реализованы как последовательности значений типа char. Тип char позволяет задавать кодовые единицы, представляющие кодовые точки Unicode в кодировке UTF-16.

**Источник.** [https://pro-java.ru/java-dlya-nachinayushhix/kodovye-tochki-i-kodovye-edinicy-java/]

Вопрос 25.
Объясните назначение метода intern().
Что появится в консоли в результате работы фрагмента программы?
class GFG {
public static void main(String[] args) {
String s1 = new String("GFG");
String s2 = s1.intern();
System.out.println(s1 == s2);
System.out.println(s1.equals(s2));
String s3 = "GFG";
System.out.println(s2 == s3);
}
}
Поясните ответ.

**Ответ:**
Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом equals(Object), тогда возвращается ссылка на строку из пула. В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается. Этот метод всегда возвращает строку, которая имеет то же значение, что что и текущая строка, но гарантирует что это будет строка из пула уникальных строк.
false
true
true
**Источник.** [https://javarush.ru/groups/posts/760-java-string-voprosih-k-sobesedovaniju-i-otvetih-na-nikh-ch2]

Вопрос 26.
Как преобразовать строку в число?

**Ответ:**
byte b = Byte.parseByte("123");
short s = Short.parseShort("123");
int i = Integer.parseInt("123");
long l = Long.parseLong("123");
float f = Float.parseFloat("123.4");
double d = Double.parseDouble("123.4e1

Делать это лучше с помощью метода parseInt класса Integer. Метод parseInt должен преобразовать String в int и выдает исключение NumberFormatException, если строка не может быть преобразована в тип int.

**Источник.** [https://javarush.ru/groups/posts/244-vopros-otvet-kak-v-java-praviljhno-konvertirovatjh-string-v-int--]

Вопрос 27.
Какой метод вызывается для преобразования переменной в строку?

**Ответ:**
Integer.toString(int)
Класс Integer имеет статический метод, который возвращает объект String, представляющий параметр int, указанный в функции Integer.toString(int). Этот подход, в отличие от других, может возвращать исключение NullPointerException.
String.valueOf(int)
String.valueOf() – это статический служебный метод класса String, который может преобразовывать большинство примитивных типов данных в их представление String. Включает целые числа. Этот подход считается лучшей практикой благодаря своей простоте.
String.format()
String.format() – это новый альтернативный метод, который можно использовать для преобразования Integer в объект String. Хотя целью этого метода является форматирование строки, его также можно использовать для преобразования.

**Источник.** [https://javarush.ru/groups/posts/244-vopros-otvet-kak-v-java-praviljhno-konvertirovatjh-string-v-int--]

Вопрос 28.
Каким методом в классе String можно проверить строку на соответствие регулярному выражению?

**Ответ:**
boolean matches(String regex, CharSequence input) — проверяет на соответствие строки input шаблону regex;

**Источник.** [И. Блинов. Глава 7. Строки.]

Вопрос 29.
Создайте класс с полями: int, long, float и double, String.
Сделайте для этого класса метод toString(), использующий String.format(), и выведите содержимое полей на экран в произвольном порядке, используя спецификаторы.

Вопрос 30.
Опишите:
•	назначение класса Formatter,
•	методы format(),
•	спецификаторы формата.

**Ответ:**
•	Интерпретатор строк формата printf. Этот класс обеспечивает поддержку выравнивания и выравнивания макета, общих форматов для числовых, строковых данных и данных даты / времени, а также вывода, зависящего от локали. Общие типы Java , такие как byte, BigDecimalи Calendar поддерживаются. Ограниченная настройка форматирования для произвольных типов пользователей предоставляется через Formattableинтерфейс.
•	В классе Formatter объявлен метод format(), который преобразует переданные в него параметры в строку заданного формата и сохраняет в объекте типа Formatter.
•
Спецификатор формата|	Выполняемое форматирование                                |         
|:-----------------:|:------------------------------------------------------------|
|                 %s|	Любой тип, который будет приведен к строке                |
|:-----------------:|:------------------------------------------------------------|
|                 %b|	Любой тип, который будет приведен к boolean: true —       |
|                   |   если значение не null, false — если null                  |
|:-----------------:|:------------------------------------------------------------|
|                 %h|	Можно передавать любой объект, который будет приведен к   |
|                   |   шестнадцатеричной строке значения из метода hashCode ()   |
|:-----------------:|:------------------------------------------------------------|
|                 %c|	Используется для задания символа Unicode (char)           |
|:-----------------:|:------------------------------------------------------------|
|                 %d|	Задается целое число (int. byte, short, int, long,        |
|                   |     BigInteger)                                             |
|:-----------------:|:------------------------------------------------------------|
|                 %f|	Используется для задания числа с плавающей запятой        |
|:-----------------:|:------------------------------------------------------------|
|                 %e|	Числа с плавающей запятой в экспоненциальном представлении|
|:-----------------:|:------------------------------------------------------------|
|                 %a|	Числа с плавающей запятой будут представлены в            | 
|                   |     шестнадцатеричном виде                                  |
|:-----------------:|:------------------------------------------------------------|
|                 %x|	Передается целое число (int. byte, short, int,            |
|                   |   long, BigInteger), результатом форматирования будет символ|
|                   |   под данным номером в таблице ASCII                        |
|:-----------------:|:------------------------------------------------------------|
|                 %o|	Принимается целое число (int. byte, short, int, long,     |
|                   |   BigInteger), которое будет представлено в виде            |
|                   |   восьмеричного числа                                       |
|:-----------------:|:------------------------------------------------------------|
|                 %t|	Префикс для преобразований даты и времени. Для форматиро- |
|                   |   вания требуются дополнительные флаги                      |
|:-----------------:|:------------------------------------------------------------|
|                 %n|	Разделитель строк для конкретной платформы. Аналог \n     |
|:-----------------:|:------------------------------------------------------------|

**Источник.** [https://javarush.ru/groups/posts/1412-formatiruem-vihvod-chisel-v-java]
[https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html]
[И. Блинов. Глава 7. Строки. Под раздел. Форматирование строк]

Вопрос 31.
Что представляет собой регулярное выражение?
На каких классах базируются regex-возможности языка Java?
В каком пакете эти классы расположены?

**Ответ:**
Класс java.util.regex.Pattern применяется для определения регулярных выражений (шаблонов), для которых ищется соответствие в строке, файле или другом объекте, представляющем последовательность символов. Для определения шаблона применяются специальные синтаксические конструкции.
Расположены в пакете java.util.regex
Пакет java.util.regex исходно состоит из следующих трех классов:
•	Pattern Class – объект класса Pattern представляет скомпилированное представление регулярного выражения.
•	Matcher Class – объект класса Matcher представляет механизм, который интерпретирует шаблон, а также производит операции сопоставления с вводимой строкой.
•	PatternSyntaxException – объект класса PatternSyntaxException представляет непроверяемое исключение, которое обозначает синтаксическую ошибку в шаблоне регулярного выражения.

**Источник.** [И. Блинов. Глава 7. Строки.]
[http://proglang.su/java/regular-expressions]

Вопрос 32.
Опишите назначение классов Pattern и Matcher.
Каким образом они связываются?
Предоставить простейший код их взаимодействия.

**Ответ:**
Класс Pattern — это конструктор регулярных выражений. Под «капотом» метод compile вызывает закрытый конструктор класса Pattern для создания скомпилированного представления. Такой способ создания экземпляра шаблона реализован с целью создания его в виде неизменяемого объекта. При создании производится синтаксическая проверка регулярного выражения. При наличии ошибок в строке – генерируется исключение PatternSyntaxException.
Класс Pattern используется для простой обработки строк. Для более сложной обработки строк используется класс Matcher, рассматриваемый ниже.
Pattern pattern1 = Pattern.compile(PATTERN_VALIDATION);
Matcher matcher1 = pattern1.matcher(key.substring(KEY_INDEX_LENGHT));
**Источник.** [И. Блинов. Глава 7. Строки.]

Вопрос 33.
При помощи регулярных выражений найти все ссылки внутри веб-страницы, то есть адреса, указанные в атрибуте href.

**Ответ:** 
$pattern = "/<a href="[^>]+">.+?<\/a>/";

Вопрос 34.
Какой из способов сравнения строк предпочтительнее?
str.equals("abc");
или
"abc".equals(str);
Поясните ответ.

**Ответ:** 
Лучше "abc".equals(str). Проверка на null в этом случае не нужна.

**Источник.** [http://skipy.ru/technics/strings.html]

Вопрос 35.
Как сравнить объекты StringBuilder и StringBuffer?

**Ответ:**
Пример сравнения двух объектов. Вывод в консоль: true
public static void main(String[] args) {
StringBuilder sb = new StringBuilder();
sb.append("test");
StringBuffer sb2 = new StringBuffer();
sb2.append("test");
System.out.println(sb.toString().equals(sb2.toString()));
}
Для сравнения объектов классов String и StringBuffer их необходимо привести к одному виду.
В классе StringBuffer есть метод toString(), который отдает содержимое StringBuffer в виде объекта класса String.

**Источник.** [И. Блинов. Глава 7. Строки.]

Вопрос 36.
Что появится в консоли в результате работы фрагмента программы?
System.out.printf(
"%d студентов пришли сдавать зачет по %8.10s, \n"
+ "из них не сдали %d, %s",
10, "J2SE", 5, "а остальные сдали на отлично"
);
Поясните ответ.
Ответ:


Вопрос 37.
Сформировать регулярное выражение, при помощи которого можно выбрать все страницы, начинающиеся с "http" или "https" и заканчивающиеся на "by".

Вопрос 38.
Сформировать регулярное выражение, при помощи которого можно выбрать все значения URL-запроса с ресурса https://bsut.by.
Например, запрос https://bsut.by?value1=5&value2=10&iscan=true.
Вывод
value1=5
value2=10
iscan=true

Вопрос 39.
Базовые конструкции регулярных выражений, синтаксис (очень коротко, суть). Специальные символы, основные логические конструкции, предопределенные классы символов, логические операции, квантификаторы, группы.

**Ответ:**
Стандартных классов символов:
[abc] -a, b или c
[^abc] - символ, исключая a, b и c
[a-z] -символ между a и z
[a-d[m-p]] - между a и d, или между m и p
Логические конструкции:
Ab - после a следует b
a|b - a либо b
(a) - а
Квантификаторы:
a? - a один раз или ни разу
a* - a ноль или более раз
a+ - a один или более раз
a{n } - a n раз
a{n,} - a n или более раз
a{n,m} - a от n до m
Предопределенные классы символов:
. - любой символ
\d или \p{Digit} - [0-9]
\D - [^0-9]
\s или \p{Space} - [ \t\n\x0B\f\r]
\S - [^\s]
\w - [0-9_A-Za-z]
\W - [^\w]
\p{Lower} - [a-z]
\p{Upper} - [A-Z]
\p{Punkt} - !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
\p{Blank} - Пробел или табуляция

**Источник.** [И. Блинов. Глава 7. Строки.]

Вопрос 40.
Назовите основные, на ваш взгляд, методы класса Pattern.

**Ответ:**
Pattern compile(String regex) — возвращает Pattern, который соответствует regex;
boolean matches(String regex, CharSequence input) — проверяет на соответствие строки input шаблону regex;
String[] split(CharSequence input) — разбивает строку input, учитывая, что разделителем является шаблон;
Matcher matcher(CharSequence input) — возвращает Matcher, с помощью которого можно находить соответствия в строке input.

**Источник.** [И. Блинов. Глава 7. Строки.]

Вопрос 41.
Назовите основные, на ваш взгляд, методы класса Matcher.

**Ответ:**
Методы индекса предоставляют полезные значения индекса, которые точно показывают, где было найдено совпадение во входной строке:
•	public int start(): Возвращает начальный индекс предыдущего совпадения.
•	public int end(): Возвращает смещение после последнего совпавшего символа.
Методы исследования
Методы исследования просматривают входную строку и возвращают логическое значение, указывающее, найден ли шаблон.
•	public boolean lookingAt(): Пытается сопоставить входную последовательность, начиная с начала области, с шаблоном.
•	public boolean find(): Пытается найти следующую подпоследовательность входной последовательности, которая соответствует шаблону.
•	public boolean matches(): Пытается сопоставить весь регион с шаблоном.
Методы замены
Методы замены - это полезные методы замены текста во входной строке.
•	public Matcher appendReplacement(StringBuffer sb, String replacement): Реализует нетерминальный шаг добавления и замены.
•	public StringBuffer appendTail(StringBuffer sb): Реализует терминальный шаг добавления и замены.
•	public String replaceAll(String replacement): Заменяет каждую подпоследовательность входной последовательности, которая соответствует шаблону, заданной строкой замены.
•	public String replaceFirst(String replacement): Заменяет первую подпоследовательность входной последовательности, которая соответствует шаблону, заданной строкой замены.
•	public static String quoteReplacement(String s): Возвращает буквальную замену Stringуказанного String. Этот метод создает объект, Stringкоторый будет работать как буквальная замена sв appendReplacementметоде Matcherкласса. Произведенный Stringбудет соответствовать последовательности символов, sрассматриваемой как буквальная последовательность. '\'Знаки косой черты ( ) и доллара ( '$') не будут иметь особого значения.

**Источник.** [И. Блинов. Глава 7. Строки.]
[https://docs.oracle.com/javase/tutorial/essential/regex/matcher.html]

Вопрос 42.
Что появится в консоли в результате работы фрагмента программы?
System.out.println{"-1234".matches("-?\\d+"));
System. out. println ("5678". matches (" - ? \ \d+"));
System.out.println("+9ll".matches("-?\\d+"));
System.out.println("+911".matches("(-|\\+)?\\d+"));
Поясните ответ.

Вопрос 43.
Что появится в консоли в результате работы фрагмента программы?
System.out.println(
Arrays
.toString("Then, when you have found the gold."
.split("n\\W+")
)
);
Поясните ответ.

**Ответ:**
[The, whe, you have found the gold.]
Шаблон поиска символа n кроме один и более раз.
Метод split()  ищет вхождения в строку заданного регулярного выражения и делит исходную строку в соответствии с этим на массив строк.

**Источник.** [https://javarush.ru/groups/posts/regulyarnye-vyrazheniya-v-java]

Вопрос 44.
Сформируйте и протестируйте регулярное выражение, которое проверяет, что предложение начинается с прописной буквы и завершается точкой.

**Ответ:**
^[A-Z]\w*\W+(?:\b(?:\w+)\W*)+.

Вопрос 45.
Сформируйте и протестируйте регулярное выражение, которое заменяет все гласные подчеркиваниями в предложении
"Then, when you have found the gold".

**Ответ:**
String input="Then, when you have found the gold".
System.out.println(input.replaceAll("[aeyoiu]","_"));

Вопрос 46.
Определите, будет ли найдено в строке
"Java now has regular expressions"
совпадение для следующих выражений:
^Java
\Breg.*
n.w\s+h(a|i)s
s?
s*
s+
S{4}
S{1}
S{0,3}
Поясните ответ.

**Ответ:**
^Java – True, элемент стоит в начале строки.
\Breg.* -False, поиск на границе слова reg один или более раз
n.w\s+h(a|i)s – false ,n + любой символ+ w + символ пробела+ h +a или I + s.
s? – false один или отсутствует
s* - false ноль или более раз
s+ - True один или более раз
S{4} – false, S повторяется 4 раза
S{1} – false, повторяется один раз.
S{0,3} – false S повторяется не менее 0 и не более 3 раз


Вопрос 47.
Примените регулярное выражение
(?i)((^[aeiou])|(\s+[aeiou]))\w+?[aeiou]\b
к строке
"Arline ate eight apples and one orange while Anita hadn't any"
Поясните ответ.

Вопрос 48.
Какие подстроки извлекают следующие регулярные выражения?
[0-6]
[^n-p]
[A-Za-z0-9_]
\w
[A-C][n-p][a-c]
waz{3,5}up
[abc]+
.*

**Ответ:**
[0-6] – диапазон от 0 до 6
[^n-p] – любые символы кроме диапазона
[A-Za-z0-9_] -
\w - буквенно-цифровой символ или знак подчёркивания
[A-C][n-p][a-c] – Три диапазона
waz{3,5}up – не менее 3 раз, не более 5 в верхнем регистре
[abc]+ - три символа один и более раз
.* - любой символ ноль или болле раз

Вопрос 49.
Сформируйте регулярное выражение, которое находит предложения, начинающиеся с "Input:" и заканчивающиеся на "successful".

Вопрос 50
Сформируйте регулярное выражение, которое выделяет в обрабатываемом тексте названия файлов (имя + расширение) графических форматов gif, png, jpg.

